# 변수

### 데이터 타입
* 숫자
    * 자바스크립트 에서는 정수와 실수값을 구분하지 않고 모두 64비트의 실수로 표현한다.
    * 배열 인덱싱과 비트 연산과 같은 특정연산은 32비트 정수로 수행한다.
    * 표현이 가능한 범위를 벗어난 숫자는 (+/-)Infinity 로 표현된다.
    * 또한 오버플로우, 언터플로우, 0 에 관한 별도의 에러를 발생시키지 않는다.
    * 0을 0으로 나누는 연산은 정의된 값으로 표현할 수가 없기에 'NaN' 이라는 키워드로 표현된다.
    (여기에 보글보글 스폰지밥 삼위일체 그림 추가)
* 문자
    * 딱히 정리할 필요는 없어 보인다.
    * '\' 를 활용하여 문자열 사이에 특별히 표한하고자 하는 문자를 삽입할 수 있다.
* 정규표현식 
    * RegExp() 생성자라는 것을 통해서 문자열을 검증할 수 있다.
    * 에초에 정규표현식은 가독성이 지나치게 떨어지기 떄문에 본인은 주로 [정규표현식 검증](https://regex101.com/r/uJ0bS8/1) 해당 사이트를 활용한다.
* null : 값이 없다.
* undefined : 초기화 되지 않은 변수나 기타요소에 접근하려 할때 발생되는 일종의 전역 프로퍼티
* 묵시적, 명시적 타입의 형변환
    * 자바스크립트는 비교적 형변환에 대해서 유연하다.
    * 그러나 자바스크립트의 이와 같은 특성 때문에 골치를 썩었던 경험을 남기고자 한다.
    * [틸드 그림 첨부]
    * 명시적으로 간단한 형변환을 취해 별도의 wrapper 객체를 활용하는 것보다   
    간편하게 숫자형태로 형변환을 가미했으나, 앞서 말한 특정 연산자는 32비트 이내로   
    표현이 가능하기 때문에 명시적인 형변환이라고 하더라도 안심해서는 안된다.
### 변수
### 객체
* 객체(기초)
    * 자바스크립트의 기본 데이터 타입이다.
    * 복합적인 요소를 가지고 있는 값으로 생각하면된다.
    * 프로퍼티 혹은 명명되어 있는 값들의 집합을 의미한다.
    * 내부요소는 '.' 을 통하여 참조가 가능하다.
    * 문자열 리터럴은 객체가 아니지만 내부적으로 객체로 변환되기 때문에 해당 객체에 정의된 문자열과 관련된 요소를 참조할 수 있다.
        ```
           var s = "hello word";
           s.substring(3,4);
        ```
    * 숫자와, 불리언도 위와 비슷한 이유로 필요한 메서드를 별도의 선언없이 참조할 수 있다.
    * 위와 같은 기본 리터럴들의 객체를 wrapper 객체라고 한다.
    * wrapper 에는 참조만 가능하고, 할당은 불가하기에 유의한다.
    * 객체는 mutable 과 같은 특성을 가지고 있고 간단하게 이야기하여 자신의 값을 변경이 가능하다.
        * 값으로 비교되지 않으며 참조에 의하여 비교가 되므로 객체 내부의 특정 값과 비교하려면 '===' 과 같은 연산자, 혹은 비교 함수를 선언하여 비교한다.
    * 객체에서 원시타입 변환시 특이케이스 정리        
        * 객체를 문자열로 변환시 흐름    
            * 객체가 toString() 메서드를 통하여 반환하는 값이 원시 타입의 값이 아니라면,   
            valueOf() 메서드의 호출과정으로 원시 타입값을 확인하려하고, 둘다 없는 경우 TypeError 을 발생시킨다.          
        * 객체를 숫자로 변환시 흐름
            * 위의 문자열로 변환시 흐름과 반대로 valueOf() -> toString() -> TypeError 과정을 거친다.
            * 빈 배열을 이외 같은 경우 때문에 0 으로 반환되곤 한다. 배열은 기본적으로 valueOf() 를 상속한다.   
            또한 배열의 숫자형태 변환은 toString() 메서드에 의존한다.       
                * 배열은 때문에 다음과 같은 과정이 일어난다.
                    * [] -> "" -> 0
                    * [3] -> "3" -> 3
                    * [스크린샷 첨부] 
* 전역 객체
    * 자바스크립트 전역에서 사용하도록 정의된 심벌이다.
    * 인터프리터가 기동될 떄, 새로운 웹페이지가 로딩될 때 여러 내부에 정의된 프로퍼티들을 초기화한다.
    * undefined, Infinity, Nan 등은 전역 객체 내부에 있고 엄밀히 이야기해서 예약어는 아니지만, 동일하게 취급된다.
* 객체는 객체가 가진 고유한 프로퍼티를 유지하는 것 외에 프로토타입(Proto Type)이라 불리우는 최상위 Object의 프로퍼티를 상속받는다.
* 또한 프로퍼티는 동적으로 추가 및 제거가 가능하다.
* 여기서 말하는 프로퍼티는 key/value 형식에 존재하는 객체 내의 집합을 의미한다.
* 프로퍼티 속성(property attribute)
    * ES5 부터는 사용자가 생성한 프로퍼티의 속성만을 변경이 가능하다.
    * writable : 프로퍼티의 값의 수정 여부를 결정
    * enumerable : 프로퍼티의 이름을 for..in 구문에서 읽을 수 있는지 결정
    * configurable : 프로퍼티의 삭제/변경 가능 여부
* 오브젝트 속성(object attribute)
    * prototype : 상속받은 프로퍼티들에 대한 객체를 참조한다.
    * class : 객체의 자표형을 특정.
    * extensible : 새로운 프로퍼티를 추가할 수 있는지 여부
* 오브젝트
    * 네이티브 오브젝트 : 이미 선언되어있는 객체들의 클래스 (배열, 정규표현식, 날짜 등등)
    * 호스트 오브젝트 : 브라우저 및 자바스크립트 인터프리터가 내장된 호스트의 환경에 정의된 객
    * 사용자정의 오브젝트 : 사용자가 작성한 코드에 의해 생성된 객체
* 프로퍼티
    * 고유 프로퍼티 : 객체에 직접 정의된 프로퍼티 
    * 상속된 프로퍼티 : 해당 객체의 프로토타입 객체가 정의한 프로퍼티를 의미
* 객체의 생성방식
    * 객체 리터럴을 통한 방식
    ```
    var myObject = {};
    var myObject2 = {kbh : 32};
    ```
    * new 키워드 활용    
    ```
    var myObjectCreateByConstructor = new Object();
    var myObjectCreateByConstructor = new RegExp("js");
    ```
    * Object.create()    
        * 이해하기에 앞서 프로토타입이 무엇인가 잠시 훑어보고 넘어간다.
        * 대상이 되는 객체에 프로퍼티들을 제공해주는 객체를 의미한다.
        * 객체 리터럴 '{}' 로 선언된 모든 객체의 프로토타입은 같다.
        * 모든 프로토타입의 최상위는 Object 이며, 각 객체별로 프로토타입들이 연결된 구조를   
        프로토 타입 체인이라고 정의한다.
        * 다음을 살펴본다. Object.create에 {1} 에 인자값으로 프로토타입을 주입하여   
        넣는게 가능하며, {2}에 인자값으로 프로퍼티 속성을 주입할 수 있다.   
        {1} 인자에 생략도 가능하지만, 이럴경우 최상의 Object에 선언된 기본적인 메서드 사용불가 및   
        연산자 조차 사용이 불가능하다.
            ```
             var myObjectCreateByInjectPrototypeArgument 
                = Object.create({1},{2});
            ```
        * 특정한 프로토타입을 상속 받도록 메서드를 통해 금지 시킬 수 있으나, 내 개발 업무 내의 ES5 기준으로 이런 코드를
          작성할 일이 없기 때문에, 생략한다.
        * Object의 프로퍼티에 접근하는 방법은 다음 두가지
            ```
            var myObject = {x : 1};
            console.log(myObject['x']);
            console.log(myObject.x); 
            ```
            * 두 표현식은 동일하다. 위의 배열 형식으로 접근하기 위해 기술된 배열을 **연관 배열(associate array)**
            이라 명명되기도 하고 hash, map, dictionary 라고도 한다. 모든 오브젝트는 연관 배열이다.   
            * 타 언어는 정해진 수의 프로퍼티를 가져야 하고 반드시 프로퍼티의 이름을 미리 정의 해두어야하나   
            자바스크립트에서는 타입이 제약이 느슨하기 때문에 이런 규칙이 적용되지 않는다.   
            * 프로퍼티의 이름을 반드시 식별자로 표현해야하며, 작성자가 직접 만든 이름이르모 자료형이 존재하지 않기에    
            프로그램 실행되는 도중에 변경이 불가하다.
            * 하지만 연관배열을 사용해 객체의 프로퍼티에 접근시에는 식별자가 문자열이기 떄문에 프로그램 실행 도중   
            생성하고 접근이 가능하다. 무슨 소리이인지는 다음의 코드를 보면 알 수 있다.
            ```
            var addr = "";
            
            //가상의 customer 에 addr1, addr2 .... 등으로 이루어진 프로퍼티가 있다고 가정해보자
            
            for (i = 0; i < 4; i++){
                addr += customer["addr" + i] // 와 같은 형식으로 유동적인 접근이 가능하다.
            } 
            ```
* 프로퍼티 삭제
    * delete 키워드를 사용하면 되며, 이때 대상 객체의 고유한 프로퍼티가 아니라고 하면 삭제하지 않기 때문에 주의한다.
    * 대상 오브젝트의 프로퍼티 속성중 configurable 속성이 'false'인 경우 삭제 불가
        * nonextensible 객체에 속한 configurable 속성이 'true'인 경우 삭제가 가능
* 프로퍼티 검사
    * in, hasOwnProperty(), propertyIsEnumerable(), 직접 접근하는 방식 등으로 검사가 가능하다.
    * propertyIsEnumerable() 의 경우에는 고유한 프로퍼티가 존재하고, Enumerable 속성이 true 인 경우에만 true 값을 반환한다.
            
                          